# 第一章 可靠性、可伸缩性、可维护性

## Reliability
系统在困境（adversity，比如硬件故障、软件故障、人为错误）中仍可正常工作的能力。

硬件故障：随着集群越来越大，单个机器的故障率会逐步增大。
解决方法：首要考虑硬件的冗余，其次考虑软件的容错（比如分布式场景，单机故障不影响整集群可用）。

软件故障：往往是因为出现了编码时预期之外的场景。
解决方法：考虑系统中的各种假设和交互场景；彻底的测试；进程隔离；允许进程奔溃并重启；监控、告警以及分析。

人为错误：统计表明运维配置错误是导致服务中断的主要原因。

解决方法：

* 以最小化犯错机会的方式设计系统。例如，精心设计的抽象、API 和管理后台。使做对事情更容易，搞砸事情更困难。
* 将人们最容易犯错的地方与可能导致失效的地方 解耦（decouple）。
* 各种层面和意义上的彻底的测试【3】，尤其是 边缘场景（corner case）。
* 支持快速地恢复。 例如，快速回滚配置变更，分批发布新代码，并提供数据重算工具。
* 配置详细和明确的监控，比如性能指标和错误率。 
* 良好的管理实践与充分的培训 —— 一个复杂而重要的方面，但超出了本书的范围。

## Scalability-可伸缩性
系统应对负载增长的能力

1、描述负载：如何明确表示出当前的负载情况。找到关键负载参数，再来决定伸缩方案

2、描述性能：了解如何描述系统性能的情况。主要是响应时间和延迟时间

通常报表都会展示服务的平均响应时间。如果你想知道典型的响应时间，可以考虑p50。

如果需要考虑异常值有多糟糕，可以观察p99,p999（也被称为尾部延迟）

排队延迟通常占了高百分位点响应时间点的大部分

3、应对负载的方法：纵向伸缩（Scaling-up）和横向伸缩（Scaling-out）

务实地结合，使用几台足够强大的机器可能比使用大量的小型虚拟机更简单也更便宜。

一个良好适配应用的可伸缩架构，是围绕着 假设（assumption） 建立的：哪些操作是常见的？哪些操作是罕见的？这就是所谓负载参数。

## Maintainablitiy-可维护性

1、可操作性（Operability）：便于运维团队保持系统平稳运行。

* 通过良好的监控，提供对系统内部状态和运行时行为的 可见性（visibility）。
* 为自动化提供良好支持，将系统与标准化工具相集成。
* 避免依赖单台机器（在整个系统继续不间断运行的情况下允许机器停机维护）。
* 提供良好的文档和易于理解的操作模型（“如果做 X，会发生 Y”）。
* 提供良好的默认行为，但需要时也允许管理员自由覆盖默认值。
* 有条件时进行自我修复，但需要时也允许管理员手动控制系统状态。
* 行为可预测，最大限度减少意外。

2、简单性（Simplicity）：从系统中消除尽可能多的 复杂度（complexity），使新工程师也能轻松理解系统。

用于消除 额外复杂度 的最好工具之一是 抽象（abstraction）。一个好的抽象可以将大量实现细节隐藏在一个干净，简单易懂的外观下面。

3、可演化性（evolvability）：使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为 可伸缩性（extensibility）、可修改性（modifiability） 或 可塑性（plasticity）。

开放封闭原则：对扩展开放，对修改封闭。
