# 第三章 存储与检索

数据库常见的两种存储引擎：**日志结构（log-structured**和**面向页面（page-oriented)**

许多数据库在内部使用了日志（log），一个仅追加（append-only）的数据文件。
为了高效查找特定键的值，需要一个数据结构：索引（index）。索引是从主数据衍生的额外的架构。这不会影响数据的内容，而只会影响查询的性能。

K-V Data
KV存储与字典（dictionary）类型非常相似，通常字典都是用散列映射（hash map）或散列表（hash table）实现的。
通过散列索引记录数据：k为键值，V为文件中的偏移量，通过仅追加来不断更新K和V。旧有的段可以通过后台的定期合并来减少存储文件的大小。

append-only的意义：
• 追加和分段合并都是顺序写入操作，比随机写入快得多。
• 如果段文件是仅追加的或不可变的，并发和崩溃恢复就简单多了。
• 合并旧段的处理也可以避免数据文件随着时间推移而碎片化的问题

散列索引的局限性：
• 散列表必须能放进内存。如果键过多会变得糟糕。硬盘上实现散列映射很难表现优秀，会有大量的随机访问I/O，并且Hash冲突的处理也需要很繁琐的逻辑。
• 范围查询效率不高。无法轻松扫描xxx001和xxx999之间的所有键，只能依次单独查找。

## SSTables（Sorted String Table）：要求键值对的序列按键排序
比起散列索引的日志段，有如下优势：
1、即使文件大于可用内存，可以使用类似归并排序的方法简单快速的合并段
2、在文件中找到一个特定的键，不需要在内存中维护所有键的索引，只需要稀疏索引。
3、读取请求现在无论如何都要扫描请求范围内的多个键值对，可以将这个范围内的数据合并为块，压缩写入硬盘。除了节省硬盘空间之外，压缩还可以减少对 I/O 带宽的使用。

<img width="543" alt="image" src="https://user-images.githubusercontent.com/39869597/163806363-2b2c8c60-a5e8-4108-b9e5-484a5f0b2466.png">



### 如何构建和维护SSTable：
• 有新写入时，将其添加到内存中的平衡树数据结构（例如红黑树）。这个内存树有时被称为 内存表（memtable）。
• 当 内存表 大于某个阈值（通常为几兆字节）时，将其作为 SSTable 文件写入硬盘。这可以高效地完成，因为树已经维护了按键排序的键值对。新的 SSTable 文件将成为数据库中最新的段。当该 SSTable 被写入硬盘时，新的写入可以在一个新的内存表实例上继续进行。
• 收到读取请求时，首先尝试在内存表中找到对应的键，如果没有就在最近的硬盘段中寻找，如果还没有就在下一个较旧的段中继续寻找，以此类推。
• 时不时地，在后台运行一个合并和压缩过程，以合并段文件并将已覆盖或已删除的值丢弃掉。
> 布隆过滤器（Bloom filter）是用于近似集合内容的高效内存数据结构，它可以告诉你数据库中是不是不存在某个键，从而为不存在的键节省掉许多不必要的硬盘读取操作。


### 用SSTables制作LSM树的应用
LevelDB和RocksDB的存储引擎方案。LevelDB 可以在 Riak 中用作 Bitcask 的替代品。在 Cassandra 和 HBase 中也使用了类似的存储引擎，而且他们都受到了 Google 的 Bigtable 论文（引入了术语 SSTable 和 memtable ）的启发。
Lucene 是 Elasticsearch 和 Solr 使用的一种全文搜索的索引引擎，它使用类似的方法来存储它的关键词词典。全文索引比键值索引复杂得多，但是基于类似的想法：在搜索查询中给出一个单词，找到提及单词的所有文档（网页，产品描述等）。这是通过键值结构实现的，其中键是单词（或 词语，即 term），值是所有包含该单词的文档的 ID 列表（记录列表）。在 Lucene 中，从词语到记录列表的这种映射保存在类似于 SSTable 的有序文件中，并根据需要在后台合并。

### 性能优化
当查找数据库中不存在的键时，LSM树算法可能会很慢。通常使用额外的布隆过滤器实现。
还有一些不同的策略来确定 SSTables 被压缩和合并的顺序和时间。size-tiered 和 leveled compaction。
LevelDB和RocksDB使用leveled compaction；HBase使用size-tiered；Cassandra同时支持两种。
size-tiered，较新和较小的SSTables相继会被合并到较旧和较大的SSTables中。
Leveled compaction，key被拆分到较小的SSTables，较旧的数据被移动到单独的level，使得压缩能够更加增量地进行。

LSM 树的基本思想 —— 保存一系列在后台合并的 SSTables —— 简单而有效。即使数据集比可用内存大得多，它仍能继续正常工作。由于数据按排序顺序存储，你可以高效地执行范围查询（扫描所有从某个最小值到某个最大值之间的所有键），并且因为硬盘写入是连续的，所以 LSM 树可以支持非常高的写入吞吐量。

## B树
使用最广泛的索引结构，在几乎所有的关系数据库中，它们仍然是标准的索引实现，许多非关系数据库也会使用到 B 树。
查询场景：
<img width="575" alt="image" src="https://user-images.githubusercontent.com/39869597/163806455-6495ea44-32e7-43f1-a7c7-5af193766fe3.png">

添加场景：通过分割页面来生长 B 树
<img width="570" alt="image" src="https://user-images.githubusercontent.com/39869597/163806475-dab5c5c4-4f1f-421a-8ac0-30848eff500d.png">


### WAL让B树更可靠
B树的基本底层写操作时用新数据覆盖写硬盘上的页面，并假定覆写不改变页面的位置。即对该page的所有引用保持完整。这与日志结构索引（如 LSM 树）形成鲜明对比，后者只追加到文件（并最终删除过时的文件），但从不修改文件中已有的内容。
覆盖写的场景会带来可靠性问题。在磁性硬盘中，意味着磁头移动到正确的位置，等待旋转盘上的正确位置出现，然后用新数据覆写适当的扇区。在固态硬盘上，由于SSD必须一次擦除和重写相当大的存储芯片块，所以会发生更复杂的事情。
为了处理异常崩溃的场景，B树通常会带入一个额外的硬盘数据结构：写前日志（WAL，write-ahaead log）。这是一个仅追加的文件，所有B树的修改应用前必须先写入到该文件。出现崩溃恢复时，这个日志会用来使B树恢复到一致性状态。

### B树的优化
• 一些数据库（如 LMDB）使用写时复制方案，而不是覆盖页面并维护 WAL 以支持崩溃恢复。修改的页面被写入到不同的位置，创建新索引指向新的位置。
• 我们可以通过不存储整个键，而是缩短其大小，来节省页面空间。特别是在树内部的页面上，键只需要提供足够的信息来充当键范围之间的边界。在页面中包含更多的键允许树具有更高的分支因子，因此也就允许更少的层级。  --> B+树
• 通常，页面可以放置在硬盘上的任何位置。如果某个查询需要按照排序顺序扫描大部分的键范围，效率很低，每次页面读取可能都需要进行硬盘查找。相比之下，由于 LSM 树在合并过程中一次又一次地重写存储的大部分，所以它们更容易使顺序键在硬盘上彼此靠近。
• 额外的指针已被添加到树中。例如，每个叶子页面可以引用其左边和右边的兄弟页面，使得不用跳回父页面就能按顺序对键进行扫描。
• B 树的变体如分形树（fractal tree）借用一些日志结构的思想来减少硬盘查找（而且它们与分形无关）。

## 比较B树和LSM树
根据经验，通常 LSM 树的写入速度更快，而 B 树的读取速度更快。LSM 树上的读取通常比较慢，因为它们必须检查几种不同的数据结构和不同压缩（Compaction）层级的 SSTables。
由于反复压缩和合并 SSTables，LSM也会多次重写数据。这种影响 —— 在数据库的生命周期中每次写入数据库导致对硬盘的多次写入 —— 被称为 写放大（write amplification）。

### B树
优点：
每个键只存在于索引中的一个位置，而LSM的存储引擎可能在不同的段中有相同键的多个副本。使得B 树在强事务场景下更有利：许多关系型数据库，事务隔离是通过键范围上加锁实现的。

缺点：
索引中的每块数据必须至少写入两次：一次写入WAL，一次写入树页面本身（如果有分页还需要再写入一次）。而且是整个页面覆写的开销。

### LSM
优点：
LSM 树通常能够比 B 树支持更高的写入吞吐量，部分原因是它们有时具有较低的写放大，部分是因为它们顺序地写入紧凑的 SSTable 文件而不是必须覆写树中的几个页面。
LSM 树可以被压缩得更好，因此通常能比 B 树在硬盘上产生更小的文件。B树有一些空闲的碎片而导致空间未被使用。由于 LSM 树不是面向页面的，并且会通过定期重写 SSTables 以去除碎片，所以它们具有较低的存储开销

缺点：
压缩过程有时会干扰正在进行的读写操作。
高写入吞吐时：硬盘的有限写入带宽需要在初始写入（记录日志和刷新内存表到硬盘）和在后台运行的压缩线程之间共享。
